数据容器
1append是追加元素，extend是追加一个新的列表
2数据容器切片，可切片的为列表，集合，字符串，格式为【x:y：z】x代表头部，y代表尾部，z代表步长；可以使用【::-1】的方式来实现字符串的翻转操作，最后结果得到一个新的列表
文件
1encoding=‘UTF-8’
2w是将之前文本删除重新写，a是追加
自定义模块并使用
1若是同一模块中存在函数名相同的两个函数，在调用的时候，调用这一函数名，得到的结果是模块中后一个函数，后一个函数会将前一个函数覆盖掉
2当将主程序全部注释掉后，当前切换的模块即变成主程序
3当使用————all————后，其代表一个列表，列表内所含的函数名字符串可以被调用的模块使用，其他的函数不可以使用，若不写all，则代表默认所有函数都可以使用
装饰器
1@某一函数
下面写其他函数
表示下面的函数直接被传送到装饰器函数中
2装饰器主要使用在完善代码的时候
表示给下面这一个函数附加上@函数的功能
闭包
1闭包的外层函数的变量值会以某种形式保存下来，不会立即释放，所以可以通过这一点来保存游戏内角色的位置
2闭包相当于创建一个类似于全局变量但是只能在内外层函数之间使用，相比于全局变量不会污染程序环境，但是缺点是会占用内存
class C:
    count=0
    def __init__(self):
        C.count+=1
    @classmethod
    def get_count(cls):
        print(f"该类一共实例化了{cls.count}个对象")

c1=C()
c2=C()
c2.get_count()
c2.count=1
可以在类内部调用类本身
在类的内部实用类方法需要使用的装饰器：@classmethod 使用之后后面的函数形参使用cls
静态方法装饰器@staticmethod不需要进行绑定 可以直接使用，与之相对应的方法是实例方法，实例方法需要进行对象的绑定，能访问实例对象内部的数据
，静态方法能够访问类中的数据
多线程运行
1调用：import threading
2元组传参args（balabalabal）
3字典传参kwargs{“key”：value}
4线程名=threading.Thread(target=函数名，参数）
attr魔法方法
1getattr方法获取对象的属性数据
2setattr方法获取对象的属性数据
3delattr方法删除对象的某个属性数据
4注意setattr和delattr方法会成死亡螺旋，要使用————dict————来输入删除数据
迭代器魔法方法
1————iter————
系统进入迭代会调用这个魔法方法
2————next————
系统在迭代的每一步都会进入这个魔法方法
对象创建和删除时的魔法方法
1————new————（cls，...）
2————del————（self）
property方法
将方法变成属性，使得方法只能被访问而无法进行修改，通常情况下使用装饰器方法进行使用
在描述符的内部写上x=property（函数1，函数2，函数3）
@property接管对对象内某一属性的直接访问，后续将@property封装的方法进行处理
函数的形参
函数的形参对于对象内部的函数的形参self可以作为return的结果返回
isinstance函数
判断给出对象和后面的数据类型是否相同，若相同则返回true，反之则为fault
isinstance（对象，数据类型）
描述符
描述符只能用于类属性，不能用于对象属性，因此在对对象进行描述符的拦截时，不能成功
数据描述符->实例对象属性->非数据描述符->类属性（描述符优先级）
抽象基
抽象基类的属性只能被继承使用
文件
1读操作的相关方法
-1read.()
括号里面可以填入num，表示要从文件中读取数据的长度，如果不加则代表读取文件中的所有数据
-2f.close()
文件若是不关闭，将会被python运行的软件一直占用
-3readline和readlines
前者获得当前行，后者或者一个所有行的列表
-4with open() as f
可以自动关闭文件
2写操作的相关方法
-1写操作会在原文件清空的情况下重新写，如果没有文件名将会新建一个文件
-2文件的写操作会先写入内存，需要进行刷新，f.flush或者f.close都可以起到这样的作用
***
——加变量名表示创建一个临时变量，可以用在装饰器中最后返回，不占用内存空间
*args和**kwargs用于在函数定义和调用时传递任意数量的位置参数和关键字参数
***
关于--call--方法
当对象像函数一样被调用的时候，就会调用call方法
***
json相关使用
json.dumps(变量信息)表示将python中的语言转化为json的使用形式
在变量信息后加上，ensure-asccii=False表示在打印时json可以显示中文字符而不是乱码

